//
// Created by Sergey on 20.05.2018.
//

#include <climits>
#include <algorithm>
#include "big_integer.h"
#include <string>
#include <iostream>


big_integer::big_integer() {
    vec.resize(2);
}

big_integer::big_integer(big_integer const &other) {
    vec.resize(other.vec.size());
    std::copy(other.vec.begin(), other.vec.end(), vec.begin());
}

big_integer::big_integer(std::string str) {
    int negate = (str[0] == '-') ? -1 : 0;
    if (str[0] == '-' || str[0] == '+') {
        str.erase(0, 1);
    }
    while (!str.empty()) {
        int cur = 0;
        for (int i = 0; i < 32 && !str.empty(); ++i) {
            //нечет
            if (((str.back()) - '0') & 1) {
                cur += 1 << i;
            }
            divide_string(str);
        }
        vec.push_back(cur);
    }
    vec.push_back(0);
    if (negate) {
        *this = -*this;
    }
}

big_integer::big_integer(int a) {
    vec.push_back(a);
    (a < 0) ? vec.push_back(-1) : vec.push_back(0);
}

big_integer::~big_integer() {
    vec.clear();
}

big_integer &big_integer::operator=(big_integer const &other) {
    vec.resize(other.vec.size());
    std::copy(other.vec.begin(), other.vec.end(), vec.begin());
    return *this;
}

big_integer &big_integer::operator+=(big_integer const &rhs) {
    if (vec.size() < rhs.vec.size()) {
        vec.resize(rhs.vec.size());
    }
    //bool less = rhs.vec.size() <= vec.size();
    int carry = 0;

    /*for (int i = 0; i < rhs.vec.size(); i++) {
        int tmp = vec[i];
        vec[i] += rhs.vec[i] + carry;
        carry = ((unsigned int) vec[i] < (unsigned int) rhs.vec[i] || (unsigned int) vec[i] < (unsigned int) tmp) ? 1
                                                                                                                  : 0;
    }*/

    //можно немного ускорить, если пробегать не до vec.size, а только до rhs.vec.size
    for (int i = 0; i < vec.size(); i++){
        int addendum = (i < rhs.vec.size()) ? rhs.vec[i] : 0;
        int sum = vec[i] + addendum + carry;
        carry = ((static_cast<unsigned>(sum) < static_cast<unsigned>(addendum)) ||
                (static_cast<unsigned>(sum) < static_cast<unsigned>(vec[i]))) ? 1 : 0;
        /*if (i == rhs.vec.size() - 1 && addendum == -1){
            carry = 0;
        }*/
        vec[i] = sum;
    }
    if (vec.back() != 0 && vec.back() != -1) {
        vec.push_back((vec.back() > 0) ?  0 : 1 );
    }
    del_useless_zero(*this);
    return *this;
}

big_integer &big_integer::operator-=(big_integer const &rhs) {
    /*if (vec.size() < rhs.vec.size()) {
        vec.resize(rhs.vec.size());
    }
    int carry = 0;
    for (int i = 0; i < rhs.vec.size(); i++) {
        int tmp = vec[i];
        int res = vec[i] - rhs.vec[i];
        vec[i] = res - carry;
        carry = ((unsigned int) vec[i] > (unsigned int) tmp) ? 1 : 0;
    }
    for (auto i = rhs.vec.size(); carry == 1; i++) {
        carry = (vec[i] == INT_MIN) ? 1 : 0;
        vec[i] -= 1;

    }
    if (vec.back() != 0 && vec.back() != -1) {
        (vec.back() > 0) ? vec.push_back(0) : vec.push_back(-1);
    }
    del_useless_zero(*this);*/
    *this += (-rhs);

    return *this;
}

big_integer &big_integer::operator*=(big_integer const &rhs) {
    int sign = (vec.back() != rhs.vec.back()) ? -1 : 0;
    big_integer a, b;
    if (rhs.vec.size() > vec.size()) {
        a = rhs;
        b = *this;
    } else {
        a = *this;
        b = rhs;
    }
    if (a.vec.back() == -1) {
        a = -a;
    }
    if (b.vec.back() == -1) {
        b = -b;
    }
    big_integer ans;
    ans.vec.resize(a.vec.size() + b.vec.size());
    for (int i = 0; i < b.vec.size() - 1; ++i) {
        big_integer cur_ans;
        //todo если подумать можно обойтесь без cur
        cur_ans.vec.resize(a.vec.size() + b.vec.size() - 2);
        unsigned int carry = 0;
        for (int j = 0; j < a.vec.size() - 1; j++) {
            unsigned long long mul_digit = static_cast<unsigned long long>(static_cast<unsigned>(a.vec[j])) *
                                           static_cast<unsigned long long>(static_cast<unsigned>(b.vec[i]));
            //mul_digit *= static_cast<unsigned long long>(static_cast<unsigned>(b.vec[i]));
            mul_digit += carry;
            cur_ans.vec[i + j] = static_cast<int>(mul_digit & ((1 << 32) - 1));
            carry = static_cast<unsigned>((mul_digit) >> 32);
        }
        if (carry > 0) {
            if (i + a.vec.size() - 1 >= cur_ans.vec.size()) {
                cur_ans.vec.push_back(static_cast<int>(carry));
            } else {
                cur_ans.vec[i + a.vec.size() - 1] += (carry);
            }
        }
        ans += cur_ans;
    }
    if (sign == -1) {
        ans = -ans;
    }
    del_useless_zero(ans);
    *this = ans;
    return *this;
}

big_integer &big_integer::operator/=(big_integer const &rhs) {
    *this = div_m_in_n(*this, big_integer(rhs)).first;
    return *this;
}

big_integer &big_integer::operator%=(big_integer const &rhs) {
    *this = *this - rhs * (*this / rhs);
    return *this;
}

big_integer &big_integer::operator&=(big_integer const &rhs) {
    return bit_operation(*this, rhs, and_);
}

big_integer &big_integer::operator|=(big_integer const &rhs) {
    return bit_operation(*this, rhs, or_);
}

big_integer &big_integer::operator^=(big_integer const &rhs) {
    return bit_operation(*this, rhs, xor_);
}

big_integer &big_integer::operator<<=(unsigned rhs) {
    if (rhs < 0) return (*this >>= (rhs));
    int sign = vec.back();
    int big = rhs / 32, small = rhs % 32, r = 0;

    for (int &i : vec) {
        int tmp = (unsigned)(i) >> (32 - small);
        i <<= small;
        if (small != 0) i += r;
        r = tmp;
    }
    del_useless_zero(*this);
    std::vector<int> tmp_vec(big, 0);
    for (int i : vec) {
        tmp_vec.push_back(i);
    }
    vec = tmp_vec;
    if (vec.back() != sign) {
        vec.push_back(sign);
    }
    del_useless_zero(*this);
    return *this;
    /*del_useless_zero(*this);
    big_integer ans;
    unsigned int shift = rhs % 32;
    unsigned int dif = rhs / 32 + 1;
    ans.vec.resize(vec.size() + dif);
    ans.vec.back() = vec.back();
    unsigned int carry = 0;
    int last = ans.vec.size() - 2;
    for (int i = vec.size() - 2; i >= 0; --i) {
        unsigned long long cur_shift =
                static_cast<unsigned long long>(static_cast<unsigned int>(vec[i])) << shift;
        ans.vec[last] = left_half(cur_shift) | carry;
        carry = right_half(cur_shift);
        --last;
    }
    ans.vec[last] = carry;
    del_useless_zero(ans);
    *this = ans;
    return *this;*/
}
big_integer &big_integer::operator>>=(unsigned rhs) {
    if (rhs < 0) return (*this <<= (rhs));
    int big = rhs / 32, small = rhs % 32;

    std::vector<int> tmp_vec;
    for (int i = big; i < vec.size(); i++) {
        tmp_vec.push_back(vec[i]);
    }
    if (tmp_vec.size() == 0) tmp_vec.push_back(vec[vec.size() - 1]);
    vec = tmp_vec;

    for (int i = 0; i < vec.size() - 1; i++) {
        int tmp = vec[i + 1] % (1 << small);
        tmp <<= 32 - small;
        vec[i] = (int)((unsigned)(vec[i]) >> small);
        vec[i] += tmp;
    }
    del_useless_zero(*this);
    return *this;
    /*
    del_useless_zero(*this);
    big_integer ans;
    unsigned int shift = rhs % 32;
    if (rhs >= (vec.size() - 1) * 32) {
        *this = big_integer(vec[vec.size() - 1]);
        return *this;
    }
    ans.vec.resize(vec.size() - rhs / 32, 0);
    ans.vec[ans.vec.size() - 1] = vec[vec.size() - 1];
    unsigned int carry; // = static_cast<unsigned int>(this->vec.back);
    if (vec.back() == 0) {
        carry = 0;
    } else {
        carry = static_cast<unsigned>(vec[vec.size() - 2] >> shift);
    }
    int last = ans.vec.size() - 2;
    for (int i = vec.size() - 2; last >= 0; --i) {
        unsigned long long cur_shift =
                static_cast<unsigned long long>(static_cast<unsigned int>(vec[i])) << (32 - shift);
        ans.vec[last] = left_half(cur_shift) | carry;
        carry = right_half(cur_shift);
        --last;
    }
    //ans.vec[last] = carry;
    del_useless_zero(ans);
    *this = ans;
    return *this;*/
}
big_integer big_integer::operator+() const {
    return *this;
}

big_integer big_integer::operator-() const {
    big_integer res(*this);
    res = ~res;
    res++;
    del_useless_zero(res);
    return res;
}

big_integer big_integer::operator~() const {
    big_integer b_i(*this);
    for(auto &i : b_i.vec) {
        i = ~i;
    }
    return b_i;
}

big_integer &big_integer::operator++() {
    *this += 1;
    del_useless_zero(*this);
    return *this;
}

big_integer big_integer::operator++(int) {
    big_integer b_i(*this);
    ++(*this);
    return b_i;
}

big_integer &big_integer::operator--() {
    *this -= 1;
    del_useless_zero(*this);
    return *this;
}

big_integer big_integer::operator--(int) {
    big_integer b_i(*this);
    --(*this);
    return b_i;
}

bool operator==(big_integer const &a, big_integer const &b) {

    /*del_useless_zero(a);
    del_useless_zero(b);*/
    if (a.vec.size() != b.vec.size()) {
        return false;
    } else {
        for (int i = 0; i < a.vec.size(); i++) {
            if (a.vec[i] != b.vec[i]) {
                return false;
            }
        }
    }
    return true;
}

bool operator!=(big_integer const &a, big_integer const &b) {
    return !(a == b);
}

bool operator<=(big_integer const &a, big_integer const &b) {
    return b >= a;
}

bool operator >= (big_integer const &a, big_integer const &b) {
    big_integer dif = big_integer(a) - b;
    return (dif.vec.back()
            == 0);
    /*if (a.vec.back() == -1) {
        if (b.vec.back() == 0) {
            return false;
        } else {
            return (-a <= -b);
        }
    } else if (b.vec.back() == -1) {
        return true;
    }
    if (a.vec.size() > b.vec.size()) {
        return true;
    } else if (a.vec.size() < b.vec.size()) {
        return false;
    }
    for (auto i = a.vec.size() - 2; i >= 0; ++i) {
        if (static_cast<unsigned>(a.vec[i]) > static_cast<unsigned>(b.vec[i])) {
            return true;
        } else if (static_cast<unsigned>(a.vec[i]) < static_cast<unsigned>(b.vec[i])) {
            return false;
        }
    }*/
}

bool operator<(big_integer const &a, big_integer const &b) {
    return (a <= b) && (a != b);
}

bool operator>(big_integer const &a, big_integer const &b) {
    return (a >= b) && (a != b);
}

big_integer operator+(big_integer a, big_integer const &b) {
    return a += b;
}

big_integer operator-(big_integer a, big_integer const &b) {
    return a -= b;
}

big_integer operator*(big_integer a, big_integer const &b) {
    return a *= b;
}

big_integer operator/(big_integer a, big_integer const &b) {
    return a /= b;
}

big_integer operator<<(big_integer a, unsigned int b) {
    return a <<= b;
}

big_integer operator>>(big_integer a, unsigned int b) {
    return a >>= b;
}

std::ostream &operator<<(std::ostream &s, big_integer const &a) {
    return s << to_string(a);
}

big_integer operator%(big_integer a, big_integer const &b) {
    return a %= b;
}

big_integer operator&(big_integer a, big_integer &b) {
    return a &= b;
}

big_integer operator|(big_integer a, big_integer &b) {
    return a |= b;
}

big_integer operator^(big_integer a, big_integer  &b) {
    return a ^= b;
}

std::string to_string(big_integer const &a) {
    bool negate = a.vec.back() == -1;
    const big_integer *b_i;
    big_integer lv;
    if (negate) {
        //todo опять lvalue;
        lv = (-a);
        b_i = &lv;
    } else {
        b_i = &a;
    }
    std::string ans = "0";
    for (int i = b_i->vec.size() - 2; i >= 0; i--) {
        for (int shift = sizeof(int) * 8 - 1; shift >= 0; shift--) {
            multiply_string(ans, ((b_i->vec[i] >> shift) & 1));
        }
    }
    if (negate) {
        ans.insert(ans.begin(), '-');
    }
    return ans;
}

std::pair<big_integer, big_integer> div_m_in_n(big_integer dividend, big_integer divider) {
    big_integer tmp1(dividend), tmp2(divider);
    auto m = dividend.vec.size();
    auto n = divider.vec.size();
    if (m < n ) {
        return {big_integer(0), dividend};
    }
    if (m - 1 == 1) {
        if (dividend.vec[0] == INT_MIN && divider.vec[0] == -1) {
            return {big_integer("2147483648"), big_integer(0)};
        }
        return {big_integer(dividend.vec[0] / divider.vec[0]), big_integer(dividend.vec[0] % divider.vec[0])};
    }
    int sign = (dividend.vec.back() != divider.vec.back()) ? -1 : 0;
    if (dividend.vec.back() == -1) {
        dividend = -dividend;
    }
    if (divider.vec.back() == -1) {
        divider = -divider;
    }
    unsigned int shift = normalize(dividend, divider);
    m = dividend.vec.size();
    n = divider.vec.size();
    long long int k = m - n - 1;
    if (m - 1 == 2) {
        if (n - 1 == 1 && static_cast<unsigned >(dividend.vec[0]) >= static_cast<unsigned>(divider.vec[0])) {
            auto res = (link(dividend.vec[1], dividend.vec[0]) / static_cast<unsigned long long>(static_cast<unsigned>(divider.vec[0])));
            big_integer quotient;
            quotient.vec[0] = (static_cast<int>(right_half(res)));
            quotient.vec[1] = (static_cast<int>(left_half(res)));
            quotient.vec.push_back(0);
            if (sign == -1) {
                quotient = -quotient;
            }
            if (quotient.vec.back() == -1 && quotient.vec[1]) {
                quotient.vec.pop_back();
            }
            del_useless_zero(quotient);

            return {quotient, big_integer(0)};
        }
        if (n - 1 == 2) {
            auto res = static_cast<int>(right_half(link(dividend.vec[1], dividend.vec[0]) / link(divider.vec[1], divider.vec[0])));
            auto remainder = static_cast<int>(right_half(link(dividend.vec[1], dividend.vec[0]) % link(divider.vec[1], divider.vec[0])));
            big_integer ans(res);
            if (sign == -1) {
                ans = -ans;
            }
            return {big_integer(res), remainder};
        } else {
            std::pair<unsigned, unsigned> res = div_2_in_1(static_cast<unsigned int>(dividend.vec[1]), static_cast<unsigned int>(dividend.vec[0]), static_cast<unsigned int>(divider.vec[0]));
            big_integer ans;
            if (sign == -1) {
                ans = big_integer('-' + std::to_string(res.first));
            } else {
                ans = big_integer(res.first);
            }
            return {ans, big_integer(static_cast<int>(res.second))};
        }
    }
    if (n - 1 == 1) {
        return div_m_in_1(dividend, static_cast<unsigned>(divider.vec[0]), sign);
    }
    big_integer quotient;
    quotient.vec.resize(k + 3);
    big_integer shifted = divider << ((k+1) * 32);
    if (dividend >= shifted) {
        quotient.vec[quotient.vec.size() - 2] = 1;
        dividend -= shifted;
    } else {
        quotient.vec.pop_back();
    }

    while (k >= 0) {
        if (dividend.vec[n + k - 1] == divider.vec[n - 2] && dividend.vec[n + k - 2] == divider.vec[n - 3]) {
            quotient.vec[k] = INT_MAX;
        } else {
            quotient.vec[k] = static_cast<int>(div_3_in_2(static_cast<unsigned>(dividend.vec[n + k - 1]), static_cast<unsigned>(dividend.vec[n + k - 2]),
                                                          static_cast<unsigned>(dividend.vec[n + k - 3]), static_cast<unsigned>(divider.vec[n - 2]),
                                                          static_cast<unsigned>(divider.vec[n - 3])).first);
        }
        del_useless_zero(dividend);
        big_integer ml = big_integer(quotient.vec[k]);
        big_integer ab1 = abs(ml);
        big_integer mul = (ab1 * divider);
        big_integer sh = mul << (k * 32);
        dividend -= sh;
        //(big_integer(quotient.vec[k]) * divider) << (k * 32);
        del_useless_zero(dividend);
        if (dividend.vec.back() == -1) {
            dividend += divider;
            //--quotient.vec[k];
        }
        --k;
    }
    del_useless_zero(quotient);
    del_useless_zero(dividend);
    if (sign == -1) {
        quotient = -quotient;
    }
    return {quotient, dividend >> shift};
}

std::pair<unsigned int, unsigned long long>
div_3_in_2(unsigned int dividend1, unsigned int dividend2, unsigned int dividend3, unsigned int divider1, unsigned int divider2) {
    unsigned long long dividend = link(dividend1, dividend2);
    unsigned long long divider = link(divider1, divider2);
    unsigned long long quotient = dividend / divider1;
    unsigned long long remainder = ((dividend - quotient * divider1) << 32) | dividend3;
    unsigned long long dq = quotient * divider2;
    if (dividend1 == divider1) {
        unsigned int s1 = divider2 - dividend2;
        unsigned long long s = (static_cast<unsigned long long>(s1) << 32) - dividend3;
        if (s <= divider) {
            quotient = INT_MAX;
            remainder = divider - s;
        } else{
            quotient = INT_MAX - 1;
            remainder = divider << 1 - s;
        }
    }
    if (remainder < dq) {
        --quotient;
        remainder += divider;
        if (remainder >= divider && remainder < dq) {
            --quotient;
            remainder += divider;
        }
    }
    remainder -= dq;
    return {static_cast<unsigned>(quotient), remainder};
}

void multiply_string(std::string &str, int carry) {
    for (int i = str.length() - 1; i >= 0; i--) {
        char tmp = str[i];
        str[i] = static_cast<char >((((str[i] - '0') * 2 + carry) % 10) + '0');
        carry = (tmp - '0' >= 5) ? 1 : 0;
    }
    if (carry == 1) {
        str.insert(str.begin(), '1');
    }
}

void divide_string(std::string &str) {
    //std::string ans;
    int remainder = 0;
    int first_zero = 0;
    auto len = str.length();
    for (int i = 0; i < len; i++) {
        int digit = (str[i] - '0');
        int new_digit = ((str[i] - '0') + remainder) / 2;
        str[i] = static_cast<char>(new_digit + '0');
        if (i == 0) {
            if (new_digit == 0) {
                first_zero = -1;
            } else {
                str[i] = (static_cast<char>(new_digit + '0'));
            }
        } else {
            str[i + first_zero] = (static_cast<char>(new_digit + '0'));
        }
        remainder = (digit & 1) ? 10 : 0;
    }
    if (first_zero == -1) {
        str.pop_back();
    }
}


void del_useless_zero(big_integer &b_i) {
    while (b_i.vec.size() > 2) {
        if (b_i.vec[b_i.vec.size() - 2] == 0) {
            //todo мб erase
            if ((b_i.vec.back() == 0)) {
                b_i.vec.pop_back();
            } else if (b_i.vec.back() == -1) {
                b_i.vec.pop_back();
                b_i.vec.pop_back();
                b_i.vec.push_back(-1);
            }
        } else {
            break;
        }
    }
}

unsigned int right_half(unsigned long long arg) {
    //todo проверить static_cast<unsigned long>(arg)
    return static_cast<unsigned int>(arg & (static_cast<unsigned long long>(1 << 32) - 1));
}

unsigned int left_half(unsigned long long arg) {
    return static_cast<unsigned int>(arg >> 32);
}

unsigned long long link(int first, int second) {
    return static_cast<unsigned long long>(static_cast<unsigned>(first)) << 32 | static_cast<unsigned>(second);
}

inline unsigned int high_bit_bs(unsigned int n) {
    unsigned int size = sizeof(n) * 4;
    int res = 0;
    while (n != 1) {
        int l = n >> size;
        if (l) {
            n = l;
            res += size;

        } else {
            n ^= l << size;
        }
        size >>= 1;
    }
    return 31 - res;
}

unsigned int normalize(big_integer &dividend, big_integer &divider) {
    if (divider.vec.back() == -1) {
        return 0;
    }
    unsigned int shift = high_bit_bs(static_cast<unsigned int>(divider.vec[divider.vec.size() - 2]));
    dividend <<= shift;
    divider <<= shift;
    return shift;
}

unsigned int normalize(big_integer &dividend, unsigned int &divider) {
    if (divider > INT_MAX) {
        return 0;
    }
    unsigned int shift = high_bit_bs(divider);
    dividend <<= shift;
    divider <<= shift;
    return shift;
}

std::pair<big_integer, big_integer> div_m_in_1(big_integer dividend, unsigned int divider, int sign) {
    //unsigned long long int tmp_size = dividend.vec.size();
    unsigned int shift = normalize(dividend, divider);
    unsigned int remainder = 0;
    int i = dividend.vec.size() - 2;
    big_integer quotient;
    quotient.vec.resize(dividend.vec.size());
    while (i >= 0) {
        std::pair<unsigned, unsigned> cur_res = div_2_in_1(remainder, static_cast<unsigned>(dividend.vec[i]), divider);
        quotient.vec[i] = cur_res.first;
        remainder = cur_res.second;
        --i;
    }
    del_useless_zero(quotient);
    if (sign == -1) {
        quotient = -quotient;
    }
    return {quotient, big_integer(static_cast<int>(remainder >> shift))};
}

std::pair<unsigned, unsigned int>
div_2_in_1(unsigned int dividend1, unsigned int dividend2, unsigned int divider) {
    auto quotient = static_cast<unsigned>(link(dividend1, dividend2) / static_cast<unsigned long long>(divider));
    auto remainder = static_cast<unsigned int>(link(dividend1, dividend2) % static_cast<unsigned long long>(divider));
    return {quotient, remainder};
}

void extend(big_integer &b_i, unsigned long long int to_size) {
    int first_bit = b_i.vec.back();
    while (b_i.vec.size() != to_size) {
        b_i.vec.push_back(first_bit);
    }

}

big_integer abs(big_integer &arg) {
    if (arg >= 0) {
        return arg;
    } else {
        big_integer cp = arg;
        cp.vec.back() = 0;
        return cp;
    }
}

big_integer operator&(big_integer a, int b) {
    big_integer b_i(b);
    return a & b_i;
}

big_integer operator|(big_integer a, int b) {
    big_integer b_i(b);
    return a | b_i;
}

big_integer operator^(big_integer a, int b) {
    big_integer b_i(b);
    return a ^ b_i;
}

void or_(int &a, int const b) {
    a |= b;
}
void and_(int &a, int const b) {
    a &= b;
}
void xor_(int &a, int const b) {
    a ^= b;
}

big_integer &bit_operation(big_integer &a, big_integer const &b, void (*operation)(int &a, int const b)) {
    int first_bits = 1;
    if (a.vec.size() > b.vec.size()) {
        first_bits = b.vec.back();
    }
    if (a.vec.size() < b.vec.size()) {
        extend(a, b.vec.size());
    }
    for (int i = 0; i < b.vec.size(); ++i) {
        operation(a.vec[i], b.vec[i]);
    }
    if (b.vec.size() < a.vec.size()) {
        for (auto i = b.vec.size(); i < a.vec.size(); ++i) {
            operation(a.vec[i], first_bits);
        }
    }
    del_useless_zero(a);
    return a;
}
